/**
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 0.1.0
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
! function(a, b) { "function" == typeof define && define.amd ? define(b) : "object" == typeof module && module.exports ? module.exports = b() : a.Popper = b() }(this, function() {
    "use strict";

    function a(a, b, c) {
        this._trigger = a;
        var d = void 0 === b || null === b,
            e = "function" == typeof b,
            f = b && "Object" === b.constructor.name;
        d || e || f ? this._popper = this.parse(f ? b : {}) : this._popper = b, this._options = Object.assign({}, o, c), this._options.modifiers = this._options.modifiers.map(function(a) { if ("string" == typeof a) { if (-1 !== this._options.modifiersIgnored.indexOf(a)) return; return this.modifiers[a] } return a }.bind(this)), this._popper.setAttribute("x-placement", this._options.placement), this.update(), this._setupEventListeners(), "function" == typeof arguments[arguments.length - 1] && arguments[arguments.length - 1].call(n, this)
    }

    function b(a) {
        var b = n.getComputedStyle(a),
            c = parseFloat(b.marginTop) + parseFloat(b.marginBottom),
            d = parseFloat(b.marginLeft) + parseFloat(b.marginRight);
        return { width: a.offsetWidth + d, height: a.offsetHeight + c }
    }

    function c(a) { var b = { left: "right", right: "left", bottom: "top", top: "bottom" }; return a.replace(/left|right|bottom|top/g, function(a) { return b[a] }) }

    function d(a) { var b = Object.assign({}, a); return b.right = b.left + b.width, b.bottom = b.top + b.height, b }

    function e(a, b) {
        var c, d = 0;
        for (c in a) {
            if (a[c] === b) return d;
            d++
        }
        return null
    }

    function f(a, b) { var c = n.getComputedStyle(a, null); return c[b] }

    function g(a) { return a.offsetParent || n.document.body }

    function h(a) { return a === n.document ? n.document.body.scrollTop ? n.document.body : n.document.documentElement : -1 !== ["scroll", "auto"].indexOf(f(a, "overflow")) || -1 !== ["scroll", "auto"].indexOf(f(a, "overflow-x")) || -1 !== ["scroll", "auto"].indexOf(f(a, "overflow-y")) ? a : a.parentNode ? h(a.parentNode) : a }

    function i(a) { return a === n.document.body ? !1 : "fixed" === f(a, "position") ? !0 : a.parentNode ? i(a.parentNode) : a }

    function j(a, b) {
        function c(a) { return "" !== a && !isNaN(parseFloat(a)) && isFinite(a) }
        Object.keys(b).forEach(function(d) { var e = ""; - 1 !== ["width", "height", "top", "right", "bottom", "left"].indexOf(d) && c(b[d]) && (e = "px"), a.style[d] = b[d] + e })
    }

    function k(a) { var b = {}; return a && "[object Function]" === b.toString.call(a) }

    function l(a, b) {
        var c = h(a),
            d = g(a),
            e = 0,
            f = 0;
        (d === c || d.contains(c)) && b && (e = c.scrollTop, f = c.scrollLeft);
        var i = { width: a.offsetWidth, height: a.offsetHeight, left: a.offsetLeft - f, top: a.offsetTop - e };
        return i.right = i.left + i.width, i.bottom = i.top + i.height, i.scrollTop = e, i.scrollLeft = f, i
    }

    function m(a) { for (var b = ["", "ms", "webkit", "moz", "o"], c = 0; c < b.length; c++) { var d = b[c] ? b[c] + a.charAt(0).toUpperCase() + a.slice(1) : a; if ("undefined" != typeof n.document.body.style[d]) return d } return null }
    var n = window,
        o = { placement: "bottom", gpuAcceleration: !0, offset: 0, boundariesElement: "viewport", boundariesPadding: 5, preventOverflowOrder: ["left", "right", "top", "bottom"], flipBehavior: "flip", arrowElement: "[x-arrow]", modifiers: ["shift", "offset", "preventOverflow", "keepTogether", "arrow", "flip"], modifiersIgnored: [] };
    a.prototype.destroy = function() { this._popper.removeAttribute("x-placement"), this._popper.style.left = "", this._popper.style.position = "", this._popper.style.top = "", this._popper.style[m("transform")] = "", this._removeEventListeners() }, a.prototype.update = function() {
        var a = {};
        a.placement = this._options.placement, a._originalPlacement = this._options.placement, a.offsets = this._getOffsets(this._popper, this._trigger, a.placement), a.boundaries = this._getBoundaries(a, this._options.boundariesPadding, this._options.boundariesElement), a = this.runModifiers(a, this._options.modifiers);
        var b, c = { position: a.offsets.popper.position };
        this._options.gpuAcceleration && (b = m("transform")) ? (c[b] = "translate3d(" + a.offsets.popper.left + "px, " + a.offsets.popper.top + "px, 0)", c.top = 0, c.left = 0) : (c.left = a.offsets.popper.left, c.top = a.offsets.popper.top), j(this._popper, c), this._popper.setAttribute("x-placement", a.placement)
    }, a.prototype.parse = function(a) {
        function b(a, b) { b.forEach(function(b) { a.classList.add(b) }) }

        function c(a, b) { b.forEach(function(b) { a.setAttribute(b.split(":")[0], b.split(":")[1]) }) }
        var d = { tagName: "div", classNames: ["popper"], attributes: [], parent: n.document.body, content: "", allowHtml: !1, arrow: { tagName: "div", classNames: ["popper__arrow"], attributes: ["x-arrow"] } };
        a = Object.assign({}, d, a);
        var e = n.document,
            f = e.createElement(a.tagName);
        if (b(f, a.classNames), c(f, a.attributes), a.allowHtml ? f.innerHTML = a.content : f.textContent = a.content, a.arrow) {
            var g = e.createElement(a.arrow.tagName);
            b(g, a.arrow.classNames), c(g, a.arrow.attributes), f.appendChild(g)
        }
        var h = a.parent;
        if ("string" == typeof h) {
            if (h = e.querySelectorAll(a.parent), h.length > 1 && console.warning("WARNING: the given `parent` query(" + a.parent + ") matched more than one element, the first one will be used"), 0 === h.length) throw "ERROR: the given `parent` doesn't exists!";
            h = h[0]
        }
        return h.length > 1 && (console.warning("WARNING: you have passed as parent a list of elements, the first one will be used"), h = h[0]), h.appendChild(f), f
    }, a.prototype._getOffsets = function(a, c, d) {
        var e = g(c);
        d = d.split("-")[0];
        var f = l(c, !0),
            h = b(a),
            j = {}; - 1 !== ["right", "left"].indexOf(d) ? (j.top = f.top + f.height / 2 - h.height / 2, "left" === d ? j.left = f.left - h.width : j.left = f.right) : (j.left = f.left + f.width / 2 - h.width / 2, "top" === d ? j.top = f.top - h.height : j.top = f.bottom), j.width = h.width, j.height = h.height;
        var k = i(c, e);
        return j.position = k ? "fixed" : "absolute", { popper: j, trigger: f }
    };
    var p = null;
    return a.prototype._setupEventListeners = function() {
        if (p = this.update.bind(this), n.addEventListener("resize", p), "window" !== this._options.boundariesElement) {
            var a = h(this._trigger);
            a !== n.document.body && a !== n.document.documentElement || (a = n), a.addEventListener("scroll", p)
        }
    }, a.prototype._removeEventListeners = function() {
        if (n.removeEventListener("resize", p), "window" !== this._options.boundariesElement) {
            var a = h(this._trigger);
            a !== n.document.body && a !== n.document.documentElement || (a = n), a.removeEventListener("scroll", p)
        }
        p = null
    }, a.prototype._getBoundaries = function(a, b, c) {
        var d, e, f = {};
        if ("window" === c) {
            var i = n.document.body,
                j = n.document.documentElement;
            e = Math.max(i.scrollHeight, i.offsetHeight, j.clientHeight, j.scrollHeight, j.offsetHeight), d = Math.max(i.scrollWidth, i.offsetWidth, j.clientWidth, j.scrollWidth, j.offsetWidth), f = { top: 0, right: d, bottom: e, left: 0 }
        } else if ("viewport" === c) {
            var k = g(this._popper),
                m = h(this._popper),
                o = l(k);
            f = { top: 0 - (o.top - m.scrollTop), right: n.document.documentElement.clientWidth - o.left, bottom: n.document.documentElement.clientHeight - (o.top - m.scrollTop), left: 0 - o.left }
        } else f = g(this._popper) === c ? { top: 0, left: 0, right: c.clientWidth, bottom: c.clientHeight } : l(c);
        return f.left += b, f.right -= b, f.top = f.top + b, f.bottom = f.bottom - b, f
    }, a.prototype.runModifiers = function(a, b, c) { var d = b.slice(); return void 0 !== c && (d = this._options.modifiers.slice(0, e(this._options.modifiers, c))), d.forEach(function(b) { k(b) && (a = b.call(this, a)) }.bind(this)), a }, a.prototype.isModifierRequired = function(a, b) { var c = e(this._options.modifiers, a); return !!this._options.modifiers.slice(0, c).filter(function(a) { return a === b }).length }, a.prototype.modifiers = {}, a.prototype.modifiers.shift = function(a) {
        var b = a.offsets.trigger,
            c = d(a.offsets.popper),
            e = a.placement,
            f = e.split("-")[1];
        if (!f) return a;
        var g = { y: { start: b.top, end: b.top + b.height - c.height }, x: { start: b.left, end: b.left + b.width - c.width } },
            h = { bottom: function() { return { left: g.x[f] } }, top: function() { return { left: g.x[f] } }, left: function() { return { top: g.y[f] } }, right: function() { return { top: g.y[f] } } };
        return c = Object.assign(c, h[e.split("-")[0]]()), a.offsets.popper = c, a
    }, a.prototype.modifiers.preventOverflow = function(a) {
        var b = this._options.preventOverflowOrder,
            c = d(a.offsets.popper),
            e = { left: function() { var b = c.left; return c.left < a.boundaries.left && (b = Math.max(c.left, a.boundaries.left)), { left: b } }, right: function() { var b = c.left; return c.right > a.boundaries.right && (b = Math.min(c.left, a.boundaries.right - c.width)), { left: b } }, top: function() { var b = c.top; return c.top < a.boundaries.top && (b = Math.max(c.top, a.boundaries.top)), { top: b } }, bottom: function() { var b = c.top; return c.bottom > a.boundaries.bottom && (b = Math.min(c.top, a.boundaries.bottom - c.height)), { top: b } } };
        return b.forEach(function(b) { a.offsets.popper = Object.assign(c, e[b]()) }), a
    }, a.prototype.modifiers.keepTogether = function(a) {
        var b = d(a.offsets.popper),
            c = a.offsets.trigger,
            e = Math.floor;
        return b.right < e(c.left) && (a.offsets.popper.left = e(c.left) - b.width), b.left > e(c.right) && (a.offsets.popper.left = e(c.right)), b.bottom < e(c.top) && (a.offsets.popper.top = e(c.top) - b.height), b.top > e(c.bottom) && (a.offsets.popper.top = e(c.bottom)), a
    }, a.prototype.modifiers.flip = function(a) {
        if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) return console.warn("WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!"), a;
        if (a.flipped && a.placement === a._originalPlacement) return a;
        var b = a.placement.split("-")[0],
            e = c(b),
            f = a.placement.split("-")[1] || "",
            g = [];
        return g = "flip" === this._options.flipBehavior ? [b, e] : this._options.flipBehavior, g.forEach(function(h, i) {
            if (b === h && g.length !== i + 1) {
                b = a.placement.split("-")[0], e = c(b);
                var j = d(a.offsets.popper),
                    k = -1 !== ["right", "bottom"].indexOf(b);
                (k && Math.floor(a.offsets.trigger[b]) > j[e] || !k && Math.floor(a.offsets.trigger[b]) < j[e]) && (a.flipped = !0, a.placement = g[i + 1], f && (a.placement += "-" + f), a.offsets.popper = this._getOffsets(this._popper, this._trigger, a.placement).popper, a = this.runModifiers(a, this._options.modifiers, this._flip))
            }
        }.bind(this)), a
    }, a.prototype.modifiers.offset = function(a) {
        var b = this._options.offset,
            c = a.offsets.popper;
        return -1 !== a.placement.indexOf("left") ? c.top -= b : -1 !== a.placement.indexOf("right") ? c.top += b : -1 !== a.placement.indexOf("top") ? c.left -= b : -1 !== a.placement.indexOf("bottom") && (c.left += b), a
    }, a.prototype.modifiers.arrow = function(a) {
        var c = this._options.arrowElement;
        if ("string" == typeof c && (c = this._popper.querySelector(c)), !c) return a;
        if (!this._popper.contains(c)) return console.warn("WARNING: `arrowElement` must be child of its popper element!"), a;
        if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) return console.warn("WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!"), a;
        var e, f = {},
            g = a.placement.split("-")[0],
            h = d(a.offsets.popper),
            i = a.offsets.trigger,
            k = -1 !== ["left", "right"].indexOf(g);
        if (k) {
            var l = b(c).height;
            i.bottom - l < h.top && (a.offsets.popper.top -= h.top - (i.bottom - l)), i.top + l > h.bottom && (a.offsets.popper.top += i.top + l - h.bottom), e = i.top + i.height / 2 - l / 2;
            var m = e - h.top;
            m = Math.max(Math.min(h.height - l, m), 0), f.top = m, f.left = ""
        } else {
            var n = b(c).width;
            i.right - n < h.left && (a.offsets.popper.left -= h.left - (i.right - n)), i.left + n > h.right && (a.offsets.popper.left += i.left + n - h.right), e = i.left + i.width / 2 - n / 2;
            var o = e - h.left;
            o = Math.max(Math.min(h.width - n, o), 0), f.left = o, f.top = ""
        }
        return j(c, f), a
    }, Object.assign || Object.defineProperty(Object, "assign", {
        enumerable: !1,
        configurable: !0,
        writable: !0,
        value: function(a) {
            if (void 0 === a || null === a) throw new TypeError("Cannot convert first argument to object");
            for (var b = a, c = 1; c < arguments.length; c++) {
                var d = arguments[c];
                if (void 0 !== d && null !== d) {
                    d = d;
                    for (var e = Object.keys(d), f = 0, g = e.length; g > f; f++) {
                        var h = e[f],
                            i = Object.getOwnPropertyDescriptor(d, h);
                        void 0 !== i && i.enumerable && (b[h] = d[h])
                    }
                }
            }
            return b
        }
    }), a
});
//# sourceMappingURL=popper.min.js.map